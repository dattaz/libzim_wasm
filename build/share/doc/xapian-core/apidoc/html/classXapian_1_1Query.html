<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xapian: API Documentation: Xapian::Query Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xapian-core
   &#160;<span id="projectnumber">1.4.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1Query.html">Query</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classXapian_1_1Query-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::Query Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a query.  
 <a href="classXapian_1_1Query.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7e7b6b8ad0c915c2364578dfaaf6100b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> { <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bab99aad2dfc85eccc56163bc65eb0fdda">OP_AND</a> = 0
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b">OP_OR</a> = 1
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bada56688a72af48cc1cee70a5b36f2a94">OP_AND_NOT</a> = 2
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba3f186e28a8cc2a5c4cb99745dda5cedf">OP_XOR</a> = 3
, <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba5990dfefc0a0a63861630b743f507356">OP_AND_MAYBE</a> = 4
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac657f344bf26128ab7bf8fe25410b102">OP_FILTER</a> = 5
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba7a78c8353d5d06d3a38c1899ae762b21">OP_NEAR</a> = 6
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bace19bf1e7b2d8aa393aabdd061a0866e">OP_PHRASE</a> = 7
, <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba25ad30ce2b6661570ffacd8f910b6d34">OP_VALUE_RANGE</a> = 8
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba0fecaeeb3caa94b1a578fd7953cc60ee">OP_SCALE_WEIGHT</a> = 9
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba9a010fd66a56d9242d6dfae2bae0850b">OP_ELITE_SET</a> = 10
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100baf914b109cfe787be77e7c92c99626f01">OP_VALUE_GE</a> = 11
, <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bad6cede66b463ceb5f689979e1b6a8a55">OP_VALUE_LE</a> = 12
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bad8456bafb560c984aff9b4d90a00d36e">OP_SYNONYM</a> = 13
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba21a0e2b8033848ec21a6cd025bfd2ccb">OP_MAX</a> = 14
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba2c7eed8ccb36f70d9e4432be27acf83e">OP_WILDCARD</a> = 15
, <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100baf93bdb686fea46eb2dae4c36a52e0e3c">OP_INVALID</a> = 99
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100baf2af9022b2b87022860571dd93ae08bf">LEAF_TERM</a> = 100
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba1f6abfe9fe662dc944080f0c1a3be7f8">LEAF_POSTING_SOURCE</a>
, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba6ea40adb27db3ef49a43d748b475a80b">LEAF_MATCH_ALL</a>
, <br />
&#160;&#160;<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100babb387c566d074cc1f7fe2bb68d7e282a">LEAF_MATCH_NOTHING</a>
<br />
 }</td></tr>
<tr class="memdesc:a7e7b6b8ad0c915c2364578dfaaf6100b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> operators.  <a href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">More...</a><br /></td></tr>
<tr class="separator:a7e7b6b8ad0c915c2364578dfaaf6100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8b24e46a691bea139d347bc6102a9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">WILDCARD_LIMIT_ERROR</a>
, <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa08d373f6c100bdbff9420dc51a621f2">WILDCARD_LIMIT_FIRST</a>
, <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa1568bc15280d8c8a10128d3b7f1db71">WILDCARD_LIMIT_MOST_FREQUENT</a>
 }</td></tr>
<tr class="separator:a7d8b24e46a691bea139d347bc6102a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a836b588120b705758f2e25b67c781b4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c">Query</a> ()</td></tr>
<tr class="memdesc:a836b588120b705758f2e25b67c781b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a query matching no documents.  <a href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c">More...</a><br /></td></tr>
<tr class="separator:a836b588120b705758f2e25b67c781b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420644d38cde25cef056d18ce7fe1c31"><td class="memItemLeft" align="right" valign="top"><a id="a420644d38cde25cef056d18ce7fe1c31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a420644d38cde25cef056d18ce7fe1c31">~Query</a> ()</td></tr>
<tr class="memdesc:a420644d38cde25cef056d18ce7fe1c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a420644d38cde25cef056d18ce7fe1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaead3f4cc26230682ba946eb777a813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#acaead3f4cc26230682ba946eb777a813">Query</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;o)</td></tr>
<tr class="memdesc:acaead3f4cc26230682ba946eb777a813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is allowed.  <a href="classXapian_1_1Query.html#acaead3f4cc26230682ba946eb777a813">More...</a><br /></td></tr>
<tr class="separator:acaead3f4cc26230682ba946eb777a813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabb1e53cace9710f5c2c1f26b820dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#afabb1e53cace9710f5c2c1f26b820dad">operator=</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;o)</td></tr>
<tr class="memdesc:afabb1e53cace9710f5c2c1f26b820dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is allowed.  <a href="classXapian_1_1Query.html#afabb1e53cace9710f5c2c1f26b820dad">More...</a><br /></td></tr>
<tr class="separator:afabb1e53cace9710f5c2c1f26b820dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a5c36ae7d24bd571c9d8795bc687a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a735a5c36ae7d24bd571c9d8795bc687a">Query</a> (const std::string &amp;term, <a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> wqf=1, <a class="el" href="namespaceXapian.html#ae1faeb9bd109b4d78a02d4b5f7b123ed">Xapian::termpos</a> pos=0)</td></tr>
<tr class="memdesc:a735a5c36ae7d24bd571c9d8795bc687a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a term.  <a href="classXapian_1_1Query.html#a735a5c36ae7d24bd571c9d8795bc687a">More...</a><br /></td></tr>
<tr class="separator:a735a5c36ae7d24bd571c9d8795bc687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e958bc324d9f1d57908447bd8f7b5"><td class="memItemLeft" align="right" valign="top"><a id="ad75e958bc324d9f1d57908447bd8f7b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#ad75e958bc324d9f1d57908447bd8f7b5">Query</a> (<a class="el" href="classXapian_1_1PostingSource.html">Xapian::PostingSource</a> *source)</td></tr>
<tr class="memdesc:ad75e958bc324d9f1d57908447bd8f7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">PostingSource</a>. <br /></td></tr>
<tr class="separator:ad75e958bc324d9f1d57908447bd8f7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba473313f667a482badadffbd5260e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a90ba473313f667a482badadffbd5260e">Query</a> (double factor, const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;subquery)</td></tr>
<tr class="memdesc:a90ba473313f667a482badadffbd5260e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale using OP_SCALE_WEIGHT.  <a href="classXapian_1_1Query.html#a90ba473313f667a482badadffbd5260e">More...</a><br /></td></tr>
<tr class="separator:a90ba473313f667a482badadffbd5260e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9414c1bf4a4dace61bd4b19f0b2c342d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a9414c1bf4a4dace61bd4b19f0b2c342d">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;subquery, double factor)</td></tr>
<tr class="memdesc:a9414c1bf4a4dace61bd4b19f0b2c342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale using OP_SCALE_WEIGHT.  <a href="classXapian_1_1Query.html#a9414c1bf4a4dace61bd4b19f0b2c342d">More...</a><br /></td></tr>
<tr class="separator:a9414c1bf4a4dace61bd4b19f0b2c342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d63ef72945f83e1f31166d42674b7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#ae6d63ef72945f83e1f31166d42674b7a">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;a, const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;b)</td></tr>
<tr class="memdesc:ae6d63ef72945f83e1f31166d42674b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object by combining two others.  <a href="classXapian_1_1Query.html#ae6d63ef72945f83e1f31166d42674b7a">More...</a><br /></td></tr>
<tr class="separator:ae6d63ef72945f83e1f31166d42674b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0042855843d3ccfb055b1d691417ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a3b0042855843d3ccfb055b1d691417ff">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a3b0042855843d3ccfb055b1d691417ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object by combining two terms.  <a href="classXapian_1_1Query.html#a3b0042855843d3ccfb055b1d691417ff">More...</a><br /></td></tr>
<tr class="separator:a3b0042855843d3ccfb055b1d691417ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4626fc241079ea7349f47fc4e8b311"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#aea4626fc241079ea7349f47fc4e8b311">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, <a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> slot, const std::string &amp;range_limit)</td></tr>
<tr class="memdesc:aea4626fc241079ea7349f47fc4e8b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a single-ended value range.  <a href="classXapian_1_1Query.html#aea4626fc241079ea7349f47fc4e8b311">More...</a><br /></td></tr>
<tr class="separator:aea4626fc241079ea7349f47fc4e8b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31550948ccd3a016867eefaa7cdaa63d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a31550948ccd3a016867eefaa7cdaa63d">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, <a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> slot, const std::string &amp;range_lower, const std::string &amp;range_upper)</td></tr>
<tr class="memdesc:a31550948ccd3a016867eefaa7cdaa63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a value range.  <a href="classXapian_1_1Query.html#a31550948ccd3a016867eefaa7cdaa63d">More...</a><br /></td></tr>
<tr class="separator:a31550948ccd3a016867eefaa7cdaa63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae714be148ee1a35f7239515f3e0131a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#ae714be148ee1a35f7239515f3e0131a7">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, const std::string &amp;pattern, <a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> max_expansion=0, int max_type=<a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">WILDCARD_LIMIT_ERROR</a>, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> combiner=<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bad8456bafb560c984aff9b4d90a00d36e">OP_SYNONYM</a>)</td></tr>
<tr class="memdesc:ae714be148ee1a35f7239515f3e0131a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> constructor for OP_WILDCARD queries.  <a href="classXapian_1_1Query.html#ae714be148ee1a35f7239515f3e0131a7">More...</a><br /></td></tr>
<tr class="separator:ae714be148ee1a35f7239515f3e0131a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb287c496f72327d1c1411fac0570ea9"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:adb287c496f72327d1c1411fac0570ea9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#adb287c496f72327d1c1411fac0570ea9">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a> op_, I begin, I end, <a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> window=0)</td></tr>
<tr class="memdesc:adb287c496f72327d1c1411fac0570ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object from a begin/end iterator pair.  <a href="classXapian_1_1Query.html#adb287c496f72327d1c1411fac0570ea9">More...</a><br /></td></tr>
<tr class="separator:adb287c496f72327d1c1411fac0570ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1555c3eb510703f8967389e5297d9a67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a1555c3eb510703f8967389e5297d9a67">get_terms_begin</a> () const</td></tr>
<tr class="memdesc:a1555c3eb510703f8967389e5297d9a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator for terms in the query object.  <a href="classXapian_1_1Query.html#a1555c3eb510703f8967389e5297d9a67">More...</a><br /></td></tr>
<tr class="separator:a1555c3eb510703f8967389e5297d9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e80afbf89ad9f5d2362002e6e04bd76"><td class="memItemLeft" align="right" valign="top"><a id="a1e80afbf89ad9f5d2362002e6e04bd76"></a>
const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a1e80afbf89ad9f5d2362002e6e04bd76">get_terms_end</a> () const</td></tr>
<tr class="memdesc:a1e80afbf89ad9f5d2362002e6e04bd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator for terms in the query object. <br /></td></tr>
<tr class="separator:a1e80afbf89ad9f5d2362002e6e04bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c540832a4d3883a433747fd9643167f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a1c540832a4d3883a433747fd9643167f">get_unique_terms_begin</a> () const</td></tr>
<tr class="memdesc:a1c540832a4d3883a433747fd9643167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator for unique terms in the query object.  <a href="classXapian_1_1Query.html#a1c540832a4d3883a433747fd9643167f">More...</a><br /></td></tr>
<tr class="separator:a1c540832a4d3883a433747fd9643167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7962e509fe327fddc7b6ce80aef524"><td class="memItemLeft" align="right" valign="top"><a id="a6d7962e509fe327fddc7b6ce80aef524"></a>
const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a6d7962e509fe327fddc7b6ce80aef524">get_unique_terms_end</a> () const</td></tr>
<tr class="memdesc:a6d7962e509fe327fddc7b6ce80aef524"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator for unique terms in the query object. <br /></td></tr>
<tr class="separator:a6d7962e509fe327fddc7b6ce80aef524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb6db47b495c1f994fee37e81875acf"><td class="memItemLeft" align="right" valign="top"><a id="aabb6db47b495c1f994fee37e81875acf"></a>
<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#aabb6db47b495c1f994fee37e81875acf">get_length</a> () const</td></tr>
<tr class="memdesc:aabb6db47b495c1f994fee37e81875acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of this query object. <br /></td></tr>
<tr class="separator:aabb6db47b495c1f994fee37e81875acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9cec0519f2385e63837bd4b48a1d7f"><td class="memItemLeft" align="right" valign="top"><a id="a0e9cec0519f2385e63837bd4b48a1d7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f">empty</a> () const</td></tr>
<tr class="memdesc:a0e9cec0519f2385e63837bd4b48a1d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this query is <a class="el" href="classXapian_1_1Query.html#a5d2584f441d85a126004699479df0350" title="A query matching no documents.">Xapian::Query::MatchNothing</a>. <br /></td></tr>
<tr class="separator:a0e9cec0519f2385e63837bd4b48a1d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b415b392ef8961953c11cdaa0070a6f"><td class="memItemLeft" align="right" valign="top"><a id="a9b415b392ef8961953c11cdaa0070a6f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a9b415b392ef8961953c11cdaa0070a6f">serialise</a> () const</td></tr>
<tr class="memdesc:a9b415b392ef8961953c11cdaa0070a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise this object into a string. <br /></td></tr>
<tr class="separator:a9b415b392ef8961953c11cdaa0070a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b24d0b964fd7cf65148490b0b77d39"><td class="memItemLeft" align="right" valign="top"><a id="a16b24d0b964fd7cf65148490b0b77d39"></a>
<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39">get_type</a> () const</td></tr>
<tr class="memdesc:a16b24d0b964fd7cf65148490b0b77d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the top level of the query. <br /></td></tr>
<tr class="separator:a16b24d0b964fd7cf65148490b0b77d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9222af7ca331a2784e4f63f72b1ba78"><td class="memItemLeft" align="right" valign="top"><a id="ad9222af7ca331a2784e4f63f72b1ba78"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#ad9222af7ca331a2784e4f63f72b1ba78">get_num_subqueries</a> () const</td></tr>
<tr class="memdesc:ad9222af7ca331a2784e4f63f72b1ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of subqueries of the top level query. <br /></td></tr>
<tr class="separator:ad9222af7ca331a2784e4f63f72b1ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0793c72eb008ecc7f65af9d002301684"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a0793c72eb008ecc7f65af9d002301684">get_subquery</a> (size_t n) const</td></tr>
<tr class="memdesc:a0793c72eb008ecc7f65af9d002301684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a top level subquery.  <a href="classXapian_1_1Query.html#a0793c72eb008ecc7f65af9d002301684">More...</a><br /></td></tr>
<tr class="separator:a0793c72eb008ecc7f65af9d002301684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb7fbffd93a34d6a0b3d7397b960dc8"><td class="memItemLeft" align="right" valign="top"><a id="a7fb7fbffd93a34d6a0b3d7397b960dc8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a7fb7fbffd93a34d6a0b3d7397b960dc8">get_description</a> () const</td></tr>
<tr class="memdesc:a7fb7fbffd93a34d6a0b3d7397b960dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br /></td></tr>
<tr class="separator:a7fb7fbffd93a34d6a0b3d7397b960dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ff8ff94c3d91ce36c0067c0b11826"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#acd6ff8ff94c3d91ce36c0067c0b11826">operator&amp;=</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;o)</td></tr>
<tr class="memdesc:acd6ff8ff94c3d91ce36c0067c0b11826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_AND.  <a href="classXapian_1_1Query.html#acd6ff8ff94c3d91ce36c0067c0b11826">More...</a><br /></td></tr>
<tr class="separator:acd6ff8ff94c3d91ce36c0067c0b11826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f891e0fd7ea0b8e61413ebe7614c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#abb6f891e0fd7ea0b8e61413ebe7614c6">operator|=</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;o)</td></tr>
<tr class="memdesc:abb6f891e0fd7ea0b8e61413ebe7614c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_OR.  <a href="classXapian_1_1Query.html#abb6f891e0fd7ea0b8e61413ebe7614c6">More...</a><br /></td></tr>
<tr class="separator:abb6f891e0fd7ea0b8e61413ebe7614c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d0074fa1931d3be46eec1236882670"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a46d0074fa1931d3be46eec1236882670">operator^=</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;o)</td></tr>
<tr class="memdesc:a46d0074fa1931d3be46eec1236882670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_XOR.  <a href="classXapian_1_1Query.html#a46d0074fa1931d3be46eec1236882670">More...</a><br /></td></tr>
<tr class="separator:a46d0074fa1931d3be46eec1236882670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68da4f1fe46abee51aaf4d701a4e151"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#ac68da4f1fe46abee51aaf4d701a4e151">operator*=</a> (double factor)</td></tr>
<tr class="memdesc:ac68da4f1fe46abee51aaf4d701a4e151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale using OP_SCALE_WEIGHT.  <a href="classXapian_1_1Query.html#ac68da4f1fe46abee51aaf4d701a4e151">More...</a><br /></td></tr>
<tr class="separator:ac68da4f1fe46abee51aaf4d701a4e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19415437f7d083d42eecadcda974d61e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a19415437f7d083d42eecadcda974d61e">operator/=</a> (double factor)</td></tr>
<tr class="memdesc:a19415437f7d083d42eecadcda974d61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse scale using OP_SCALE_WEIGHT.  <a href="classXapian_1_1Query.html#a19415437f7d083d42eecadcda974d61e">More...</a><br /></td></tr>
<tr class="separator:a19415437f7d083d42eecadcda974d61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85df5aed850658b1a62c01e5bd1bf9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#af85df5aed850658b1a62c01e5bd1bf9d">Query</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_)</td></tr>
<tr class="memdesc:af85df5aed850658b1a62c01e5bd1bf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with just an operator.  <a href="classXapian_1_1Query.html#af85df5aed850658b1a62c01e5bd1bf9d">More...</a><br /></td></tr>
<tr class="separator:af85df5aed850658b1a62c01e5bd1bf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4fc6b251d2a822fb1b8c2892048312aa"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a4fc6b251d2a822fb1b8c2892048312aa">unserialise</a> (const std::string &amp;serialised, const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;reg=<a class="el" href="classXapian_1_1Registry.html">Registry</a>())</td></tr>
<tr class="memdesc:a4fc6b251d2a822fb1b8c2892048312aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unserialise a string and return a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object.  <a href="classXapian_1_1Query.html#a4fc6b251d2a822fb1b8c2892048312aa">More...</a><br /></td></tr>
<tr class="separator:a4fc6b251d2a822fb1b8c2892048312aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5d2584f441d85a126004699479df0350"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a5d2584f441d85a126004699479df0350">MatchNothing</a></td></tr>
<tr class="memdesc:a5d2584f441d85a126004699479df0350"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query matching no documents.  <a href="classXapian_1_1Query.html#a5d2584f441d85a126004699479df0350">More...</a><br /></td></tr>
<tr class="separator:a5d2584f441d85a126004699479df0350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e30b80314359e5ddd7ca4ffa84b6edd"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a9e30b80314359e5ddd7ca4ffa84b6edd">MatchAll</a></td></tr>
<tr class="memdesc:a9e30b80314359e5ddd7ca4ffa84b6edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query matching all documents.  <a href="classXapian_1_1Query.html#a9e30b80314359e5ddd7ca4ffa84b6edd">More...</a><br /></td></tr>
<tr class="separator:a9e30b80314359e5ddd7ca4ffa84b6edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a query. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7d8b24e46a691bea139d347bc6102a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8b24e46a691bea139d347bc6102a9a">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a"></a>WILDCARD_LIMIT_ERROR&#160;</td><td class="fielddoc"><p>Throw an error if OP_WILDCARD exceeds its expansion limit. </p>
<pre class="fragment">    Xapian::WildcardError will be thrown when the query is actually
    run.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7d8b24e46a691bea139d347bc6102a9aaa08d373f6c100bdbff9420dc51a621f2"></a>WILDCARD_LIMIT_FIRST&#160;</td><td class="fielddoc"><p>Stop expanding when OP_WILDCARD reaches its expansion limit. </p>
<pre class="fragment">    This makes the wildcard expand to only the first N terms (sorted
    by byte order).
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7d8b24e46a691bea139d347bc6102a9aaa1568bc15280d8c8a10128d3b7f1db71"></a>WILDCARD_LIMIT_MOST_FREQUENT&#160;</td><td class="fielddoc"><p>Limit OP_WILDCARD expansion to the most frequent terms. </p>
<pre class="fragment">    If OP_WILDCARD would expand to more than its expansion limit, the
    most frequent terms are taken.  This approach works well for cases
    such as expanding a partial term at the end of a query string which
    the user hasn't finished typing yet - as well as being less expense
    to evaluate than the full expansion, using only the most frequent
    terms tends to give better results too.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a7e7b6b8ad0c915c2364578dfaaf6100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7b6b8ad0c915c2364578dfaaf6100b">&#9670;&nbsp;</a></span>op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Xapian::Query::op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bab99aad2dfc85eccc56163bc65eb0fdda"></a>OP_AND&#160;</td><td class="fielddoc"><p>Match only documents which all subqueries match. </p>
<pre class="fragment">    When used in a weighted context, the weight is the sum of the
    weights for all the subqueries.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b"></a>OP_OR&#160;</td><td class="fielddoc"><p>Match documents which at least one subquery matches. </p>
<pre class="fragment">    When used in a weighted context, the weight is the sum of the
    weights for matching subqueries (so additional matching subqueries
    will mean a higher weight).
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bada56688a72af48cc1cee70a5b36f2a94"></a>OP_AND_NOT&#160;</td><td class="fielddoc"><p>Match documents which the first subquery matches but no others do. </p>
<pre class="fragment">    When used in a weighted context, the weight is just the weight of
    the first subquery.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba3f186e28a8cc2a5c4cb99745dda5cedf"></a>OP_XOR&#160;</td><td class="fielddoc"><p>Match documents which an odd number of subqueries match. </p>
<pre class="fragment">    When used in a weighted context, the weight is the sum of the
    weights for matching subqueries (so additional matching subqueries
    will mean a higher weight).
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba5990dfefc0a0a63861630b743f507356"></a>OP_AND_MAYBE&#160;</td><td class="fielddoc"><p>Match the first subquery taking extra weight from other subqueries. </p>
<pre class="fragment">    When used in a weighted context, the weight is the sum of the
    weights for matching subqueries (so additional matching subqueries
    will mean a higher weight).

    Because only the first subquery determines which documents are
    matched, in a non-weighted context only the first subquery matters.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bac657f344bf26128ab7bf8fe25410b102"></a>OP_FILTER&#160;</td><td class="fielddoc"><p>Match like OP_AND but only taking weight from the first subquery. </p>
<pre class="fragment">    When used in a non-weighted context, OP_FILTER and OP_AND are
    equivalent.

    In older 1.4.x, the third and subsequent subqueries were ignored
    in some situations.  This was fixed in 1.4.15.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba7a78c8353d5d06d3a38c1899ae762b21"></a>OP_NEAR&#160;</td><td class="fielddoc"><p>Match only documents where all subqueries match near each other. </p>
<pre class="fragment">    The subqueries must match at term positions within the specified
    window size, in any order.

    Currently subqueries must be terms or terms composed with OP_OR.

    When used in a weighted context, the weight is the sum of the
    weights for all the subqueries.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bace19bf1e7b2d8aa393aabdd061a0866e"></a>OP_PHRASE&#160;</td><td class="fielddoc"><p>Match only documents where all subqueries match near and in order. </p>
<pre class="fragment">    The subqueries must match at term positions within the specified
    window size, in the same term position order as subquery order.

    Currently subqueries must be terms or terms composed with OP_OR.

    When used in a weighted context, the weight is the sum of the
    weights for all the subqueries.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba25ad30ce2b6661570ffacd8f910b6d34"></a>OP_VALUE_RANGE&#160;</td><td class="fielddoc"><p>Match only documents where a value slot is within a given range. </p>
<pre class="fragment">    This operator never contributes weight.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba0fecaeeb3caa94b1a578fd7953cc60ee"></a>OP_SCALE_WEIGHT&#160;</td><td class="fielddoc"><p>Scale the weight contributed by a subquery. </p>
<pre class="fragment">    The weight is the weight of the subquery multiplied by the
    specified non-negative scale factor (so if the scale factor is
    zero then the subquery contributes no weight).
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba9a010fd66a56d9242d6dfae2bae0850b"></a>OP_ELITE_SET&#160;</td><td class="fielddoc"><p>Pick the best N subqueries and combine with OP_OR. </p>
<pre class="fragment">    If you want to implement a feature which finds documents similar to
    a piece of text, an obvious approach is to build an "OR" query from
    all the terms in the text, and run this query against a database
    containing the documents.  However such a query can contain a lots
    of terms and be quite slow to perform, yet many of these terms
    don't contribute usefully to the results.

    The OP_ELITE_SET operator can be used instead of OP_OR in this
    situation.  OP_ELITE_SET selects the most important ''N'' terms and
    then acts as an OP_OR query with just these, ignoring any other
    terms.  This will usually return results just as good as the full
    OP_OR query, but much faster.

    In general, the OP_ELITE_SET operator can be used when you have a
    large OR query, but it doesn't matter if the search completely
    ignores some of the less important terms in the query.

    The subqueries don't have to be terms, but if they aren't then
    OP_ELITE_SET will look at the estimated frequencies of the
    subqueries and so could pick a subset which don't actually
    match any documents even if the full OR would match some.

    You can specify a parameter to the query constructor which control
    the number of terms which OP_ELITE_SET will pick.  If not
    specified, this defaults to 10 (Xapian used to default to
    &lt;code&gt;ceil(sqrt(number_of_subqueries))&lt;/code&gt; if there are more
    than 100 subqueries, but this rather arbitrary special case was
    dropped in 1.3.0).  For example, this will pick the best 7 terms:

    &lt;pre&gt;
    Xapian::Query query(Xapian::Query::OP_ELITE_SET, subqs.begin(), subqs.end(), 7);
    &lt;/pre&gt;

   If the number of subqueries is less than this threshold,
   OP_ELITE_SET behaves identically to OP_OR.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100baf914b109cfe787be77e7c92c99626f01"></a>OP_VALUE_GE&#160;</td><td class="fielddoc"><p>Match only documents where a value slot is &gt;= a given value. </p>
<pre class="fragment">    Similar to @a OP_VALUE_RANGE, but open-ended.

    This operator never contributes weight.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bad6cede66b463ceb5f689979e1b6a8a55"></a>OP_VALUE_LE&#160;</td><td class="fielddoc"><p>Match only documents where a value slot is &lt;= a given value. </p>
<pre class="fragment">    Similar to @a OP_VALUE_RANGE, but open-ended.

    This operator never contributes weight.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100bad8456bafb560c984aff9b4d90a00d36e"></a>OP_SYNONYM&#160;</td><td class="fielddoc"><p>Match like OP_OR but weighting as if a single term. </p>
<pre class="fragment">    The weight is calculated combining the statistics for the
    subqueries to approximate the weight of a single term occurring
    with those statistics.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba21a0e2b8033848ec21a6cd025bfd2ccb"></a>OP_MAX&#160;</td><td class="fielddoc"><p>Pick the maximum weight of any subquery. </p>
<pre class="fragment">    Matches the same documents as @a OP_OR, but the weight contributed
    is the maximum weight from any matching subquery (for OP_OR, it's
    the sum of the weights from the matching subqueries).

    Added in Xapian 1.3.2.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba2c7eed8ccb36f70d9e4432be27acf83e"></a>OP_WILDCARD&#160;</td><td class="fielddoc"><p>Wildcard expansion. </p>
<pre class="fragment">    Added in Xapian 1.3.3.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100baf93bdb686fea46eb2dae4c36a52e0e3c"></a>OP_INVALID&#160;</td><td class="fielddoc"><p>Construct an invalid query. </p>
<pre class="fragment">    This can be useful as a placeholder - for example @a RangeProcessor
    uses it as a return value to indicate that a range hasn't been
    recognised.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100baf2af9022b2b87022860571dd93ae08bf"></a>LEAF_TERM&#160;</td><td class="fielddoc"><p>Value returned by <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39" title="Get the type of the top level of the query.">get_type()</a> for a term. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba1f6abfe9fe662dc944080f0c1a3be7f8"></a>LEAF_POSTING_SOURCE&#160;</td><td class="fielddoc"><p>Value returned by <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39" title="Get the type of the top level of the query.">get_type()</a> for a <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">PostingSource</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100ba6ea40adb27db3ef49a43d748b475a80b"></a>LEAF_MATCH_ALL&#160;</td><td class="fielddoc"><p>Value returned by <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39" title="Get the type of the top level of the query.">get_type()</a> for MatchAll or equivalent. </p>
<pre class="fragment">    This is returned for any &lt;code&gt;Xapian::Query(std::string())&lt;/code&gt;
    object.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a7e7b6b8ad0c915c2364578dfaaf6100babb387c566d074cc1f7fe2bb68d7e282a"></a>LEAF_MATCH_NOTHING&#160;</td><td class="fielddoc"><p>Value returned by <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39" title="Get the type of the top level of the query.">get_type()</a> for MatchNothing or equivalent. </p>
<pre class="fragment">    This is returned for any &lt;code&gt;Xapian::Query()&lt;/code&gt; object.
</pre> </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a836b588120b705758f2e25b67c781b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836b588120b705758f2e25b67c781b4c">&#9670;&nbsp;</a></span>Query() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a query matching no documents. </p>
<p><em>MatchNothing</em> is a static instance of this.</p>
<p>When combined with other <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> objects using the various supported operators, <code><a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c" title="Construct a query matching no documents.">Query()</a></code> works like <code>false</code> in boolean logic, so <code><a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c" title="Construct a query matching no documents.">Query()</a> &amp; q</code> is <code><a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c" title="Construct a query matching no documents.">Query()</a></code>, while <code><a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c" title="Construct a query matching no documents.">Query()</a> | q</code> is <code>q</code>. </p>

<p class="reference">Referenced by <a class="el" href="classXapian_1_1Query.html#acd6ff8ff94c3d91ce36c0067c0b11826">operator&amp;=()</a>, <a class="el" href="classXapian_1_1Query.html#a46d0074fa1931d3be46eec1236882670">operator^=()</a>, and <a class="el" href="classXapian_1_1Query.html#abb6f891e0fd7ea0b8e61413ebe7614c6">operator|=()</a>.</p>

</div>
</div>
<a id="acaead3f4cc26230682ba946eb777a813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaead3f4cc26230682ba946eb777a813">&#9670;&nbsp;</a></span>Query() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying is allowed. </p>
<p>The internals are reference counted, so copying is cheap. </p>

</div>
</div>
<a id="a735a5c36ae7d24bd571c9d8795bc687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735a5c36ae7d24bd571c9d8795bc687a">&#9670;&nbsp;</a></span>Query() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>wqf</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#ae1faeb9bd109b4d78a02d4b5f7b123ed">Xapian::termpos</a>&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>The term. An empty string constructs a query matching all documents (<em>MatchAll</em> is a static instance of this). </td></tr>
    <tr><td class="paramname">wqf</td><td>The within-query frequency. (default: 1) </td></tr>
    <tr><td class="paramname">pos</td><td>The query position. Currently this is mainly used to determine the order of terms obtained via <a class="el" href="classXapian_1_1Query.html#a1555c3eb510703f8967389e5297d9a67" title="Begin iterator for terms in the query object.">get_terms_begin()</a>. (default: 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ba473313f667a482badadffbd5260e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ba473313f667a482badadffbd5260e">&#9670;&nbsp;</a></span>Query() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>subquery</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale using OP_SCALE_WEIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Non-negative real number to multiply weights by. </td></tr>
    <tr><td class="paramname">subquery</td><td><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object to scale weights from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9414c1bf4a4dace61bd4b19f0b2c342d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9414c1bf4a4dace61bd4b19f0b2c342d">&#9670;&nbsp;</a></span>Query() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>subquery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scale using OP_SCALE_WEIGHT. </p>
<p>In this form, the op_ parameter is totally redundant - use Query(factor, subquery) in preference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>Must be OP_SCALE_WEIGHT. </td></tr>
    <tr><td class="paramname">factor</td><td>Non-negative real number to multiply weights by. </td></tr>
    <tr><td class="paramname">subquery</td><td><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object to scale weights from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6d63ef72945f83e1f31166d42674b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d63ef72945f83e1f31166d42674b7a">&#9670;&nbsp;</a></span>Query() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object by combining two others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>The operator to combine the queries with. </td></tr>
    <tr><td class="paramname">a</td><td>First subquery. </td></tr>
    <tr><td class="paramname">b</td><td>Second subquery. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0042855843d3ccfb055b1d691417ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0042855843d3ccfb055b1d691417ff">&#9670;&nbsp;</a></span>Query() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object by combining two terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>The operator to combine the terms with. </td></tr>
    <tr><td class="paramname">a</td><td>First term. </td></tr>
    <tr><td class="paramname">b</td><td>Second term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea4626fc241079ea7349f47fc4e8b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4626fc241079ea7349f47fc4e8b311">&#9670;&nbsp;</a></span>Query() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>range_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a single-ended value range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>Must be OP_VALUE_LE or OP_VALUE_GE currently. </td></tr>
    <tr><td class="paramname">slot</td><td>The value slot to work over. </td></tr>
    <tr><td class="paramname">range_limit</td><td>The limit of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31550948ccd3a016867eefaa7cdaa63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31550948ccd3a016867eefaa7cdaa63d">&#9670;&nbsp;</a></span>Query() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>range_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>range_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object for a value range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>Must be OP_VALUE_RANGE currently. </td></tr>
    <tr><td class="paramname">slot</td><td>The value slot to work over. </td></tr>
    <tr><td class="paramname">range_lower</td><td>Lower end of the range. </td></tr>
    <tr><td class="paramname">range_upper</td><td>Upper end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae714be148ee1a35f7239515f3e0131a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae714be148ee1a35f7239515f3e0131a7">&#9670;&nbsp;</a></span>Query() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>max_expansion</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_type</em> = <code><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">WILDCARD_LIMIT_ERROR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>combiner</em> = <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bad8456bafb560c984aff9b4d90a00d36e">OP_SYNONYM</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> constructor for OP_WILDCARD queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>Must be OP_WILDCARD </td></tr>
    <tr><td class="paramname">pattern</td><td>The wildcard pattern - currently this is just a string and the wildcard expands to terms which start with exactly this string. </td></tr>
    <tr><td class="paramname">max_expansion</td><td>The maximum number of terms to expand to (default: 0, which means no limit) </td></tr>
    <tr><td class="paramname">max_type</td><td>How to enforce max_expansion - one of <em>WILDCARD_LIMIT_ERROR</em> (the default), <em>WILDCARD_LIMIT_FIRST</em> or <em>WILDCARD_LIMIT_MOST_FREQUENT</em>. When searching multiple databases, the expansion limit is currently applied independently for each database, so the total number of terms may be higher than the limit. This is arguably a bug, and may change in future versions. </td></tr>
    <tr><td class="paramname">combiner</td><td>The <em><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b" title="Query operators.">Query::op</a></em> to combine the terms with - one of <em>OP_SYNONYM</em> (the default), <em>OP_OR</em> or <em>OP_MAX</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb287c496f72327d1c1411fac0570ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb287c496f72327d1c1411fac0570ea9">&#9670;&nbsp;</a></span>Query() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">op</a>&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>window</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object from a begin/end iterator pair. </p>
<p>Dereferencing the iterator should return a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a>, a non-NULL <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a>*, a std::string or a type which converts to one of these (e.g. const char*).</p>
<p>If begin == end then there are no subqueries and the resulting <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> won't match anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>The operator to combine the queries with. </td></tr>
    <tr><td class="paramname">begin</td><td>Begin iterator. </td></tr>
    <tr><td class="paramname">end</td><td>End iterator. </td></tr>
    <tr><td class="paramname">window</td><td>Window size for OP_NEAR and OP_PHRASE, or 0 to use the number of subqueries as the window size (default: 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af85df5aed850658b1a62c01e5bd1bf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85df5aed850658b1a62c01e5bd1bf9d">&#9670;&nbsp;</a></span>Query() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td>
          <td class="paramname"><em>op_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with just an operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_</td><td>The operator to use - currently only OP_INVALID is useful. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100baf93bdb686fea46eb2dae4c36a52e0e3c">OP_INVALID</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0793c72eb008ecc7f65af9d002301684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0793c72eb008ecc7f65af9d002301684">&#9670;&nbsp;</a></span>get_subquery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::get_subquery </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a top level subquery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Return the n-th subquery (starting from 0) - only valid when 0 &lt;= n &lt; <a class="el" href="classXapian_1_1Query.html#ad9222af7ca331a2784e4f63f72b1ba78" title="Get the number of subqueries of the top level query.">get_num_subqueries()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1555c3eb510703f8967389e5297d9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1555c3eb510703f8967389e5297d9a67">&#9670;&nbsp;</a></span>get_terms_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Query::get_terms_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin iterator for terms in the query object. </p>
<p>The iterator returns terms in ascending query position order, and will return the same term in each unique position it occurs in. If you want the terms in sorted order and without duplicates, see <a class="el" href="classXapian_1_1Query.html#a1c540832a4d3883a433747fd9643167f" title="Begin iterator for unique terms in the query object.">get_unique_terms_begin()</a>. </p>

</div>
</div>
<a id="a1c540832a4d3883a433747fd9643167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c540832a4d3883a433747fd9643167f">&#9670;&nbsp;</a></span>get_unique_terms_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Query::get_unique_terms_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin iterator for unique terms in the query object. </p>
<p>Terms are sorted and terms with the same name removed from the list.</p>
<p>If you want the terms in ascending query position order, see <a class="el" href="classXapian_1_1Query.html#a1555c3eb510703f8967389e5297d9a67" title="Begin iterator for terms in the query object.">get_terms_begin()</a>. </p>

</div>
</div>
<a id="acd6ff8ff94c3d91ce36c0067c0b11826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6ff8ff94c3d91ce36c0067c0b11826">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_AND. </p>
<dl class="section since"><dt>Since</dt><dd>Since <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.4.10, when called on a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object which is OP_AND and has a reference count of 1, then <em>o</em> is appended as a new subquery (provided <em>o</em> is a different <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object and <code>!o.<a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f" title="Check if this query is Xapian::Query::MatchNothing.">empty()</a></code>). </dd></dl>

<p class="reference">References <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39">get_type()</a>, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bab99aad2dfc85eccc56163bc65eb0fdda">OP_AND</a>, and <a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c">Query()</a>.</p>

</div>
</div>
<a id="ac68da4f1fe46abee51aaf4d701a4e151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68da4f1fe46abee51aaf4d701a4e151">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale using OP_SCALE_WEIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Non-negative real number to multiply weights by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19415437f7d083d42eecadcda974d61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19415437f7d083d42eecadcda974d61e">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse scale using OP_SCALE_WEIGHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Positive real number to divide weights by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afabb1e53cace9710f5c2c1f26b820dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabb1e53cace9710f5c2c1f26b820dad">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a>&amp; Xapian::Query::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying is allowed. </p>
<p>The internals are reference counted, so assignment is cheap. </p>

</div>
</div>
<a id="a46d0074fa1931d3be46eec1236882670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d0074fa1931d3be46eec1236882670">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_XOR. </p>
<dl class="section since"><dt>Since</dt><dd>Since <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.4.10, when called on a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object which is OP_XOR and has a reference count of 1, then <em>o</em> is appended as a new subquery (provided <em>o</em> is a different <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object and <code>!o.<a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f" title="Check if this query is Xapian::Query::MatchNothing.">empty()</a></code>). </dd></dl>

<p class="reference">References <a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f">empty()</a>, <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39">get_type()</a>, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100ba3f186e28a8cc2a5c4cb99745dda5cedf">OP_XOR</a>, and <a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c">Query()</a>.</p>

</div>
</div>
<a id="abb6f891e0fd7ea0b8e61413ebe7614c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6f891e0fd7ea0b8e61413ebe7614c6">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine with another <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object using OP_OR. </p>
<dl class="section since"><dt>Since</dt><dd>Since <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.4.10, when called on a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object which is OP_OR and has a reference count of 1, then <em>o</em> is appended as a new subquery (provided <em>o</em> is a different <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object and <code>!o.<a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f" title="Check if this query is Xapian::Query::MatchNothing.">empty()</a></code>). </dd></dl>

<p class="reference">References <a class="el" href="classXapian_1_1Query.html#a0e9cec0519f2385e63837bd4b48a1d7f">empty()</a>, <a class="el" href="classXapian_1_1Query.html#a16b24d0b964fd7cf65148490b0b77d39">get_type()</a>, <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b">OP_OR</a>, and <a class="el" href="classXapian_1_1Query.html#a836b588120b705758f2e25b67c781b4c">Query()</a>.</p>

</div>
</div>
<a id="a4fc6b251d2a822fb1b8c2892048312aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc6b251d2a822fb1b8c2892048312aa">&#9670;&nbsp;</a></span>unserialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::unserialise </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serialised</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;&#160;</td>
          <td class="paramname"><em>reg</em> = <code><a class="el" href="classXapian_1_1Registry.html">Registry</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unserialise a string and return a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialised</td><td>the string to unserialise. </td></tr>
    <tr><td class="paramname">reg</td><td><a class="el" href="classXapian_1_1Registry.html" title="Registry for user subclasses.">Xapian::Registry</a> object to use to unserialise user-subclasses of <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">Xapian::PostingSource</a> (default: standard registry). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9e30b80314359e5ddd7ca4ffa84b6edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e30b80314359e5ddd7ca4ffa84b6edd">&#9670;&nbsp;</a></span>MatchAll</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> Xapian::Query::MatchAll</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A query matching all documents. </p>
<p>This is a static instance of <code><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query(std::string())</a></code>. If you are constructing <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> objects which use <em>MatchAll</em> in different threads then the reference counting of the static object can get messed up by concurrent access so you should instead use <code><a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query(std::string())</a></code> directly. </p>

</div>
</div>
<a id="a5d2584f441d85a126004699479df0350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2584f441d85a126004699479df0350">&#9670;&nbsp;</a></span>MatchNothing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> Xapian::Query::MatchNothing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A query matching no documents. </p>
<p>This is a static instance of a default-constructed <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object. It is safe to use concurrently from different threads, unlike <em>MatchAll</em> (this is because MatchNothing has a NULL internal object so there's no reference counting happening).</p>
<p>When combined with other <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> objects using the various supported operators, MatchNothing works like <code>false</code> in boolean logic, so <code>MatchNothing &amp; q</code> is <code>MatchNothing</code>, while <code>MatchNothing | q</code> is <code>q</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="query_8h.html">query.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="https://www.doxygen.org/">Doxygen 1.9.1</a>
</small></address>
</body>
</html>
