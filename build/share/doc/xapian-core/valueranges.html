<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Value Ranges</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="value-ranges">
<h1 class="title">Value Ranges</h1>

<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#rangeprocessor" id="id2">RangeProcessor</a></li>
<li><a class="reference internal" href="#daterangeprocessor" id="id3">DateRangeProcessor</a></li>
<li><a class="reference internal" href="#numberrangeprocessor" id="id4">NumberRangeProcessor</a></li>
<li><a class="reference internal" href="#custom-subclasses" id="id5">Custom subclasses</a></li>
<li><a class="reference internal" href="#using-several-rangeprocessors" id="id6">Using Several RangeProcessors</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id1">Introduction</a></h1>
<p>The <tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt> class was introduced in Xapian 1.3.6, and
provides a powerful and flexible way to parse range queries in the users'
query string.  It's a replacement for the older <tt class="docutils literal"><span class="pre">Xapian::ValueRangeProcessor</span></tt>
class (which dates back to Xapian 1.0.0).</p>
<p>This document describes the <tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt> class and
its standard subclasses, how to create your own subclasses, and how
these classes are used with <tt class="docutils literal"><span class="pre">Xapian::QueryParser</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt> itself supports parsing string ranges, optionally
only recognising ranges with a specified prefix or suffix.  There are
standard subclasses supporting ranges of dates (<tt class="docutils literal"><span class="pre">Xapian::DateRangeProcessor</span></tt>)
and of numbers (<tt class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></tt>).  User subclasses
can support custom range types.</p>
<p><tt class="docutils literal"><span class="pre">Xapian::QueryParser</span></tt> maintains a list of <tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt> objects
which it tries in order for each range specified in the query until one accepts
it, or all have been tried (in which case an error is reported).</p>
<p>So you can support multiple filters distinguished by a prefix or suffix.  For
example, if you want to support range filters on price and weight, you can do
that like this:</p>
<pre class="literal-block">
Xapian::QueryParser qp;
Xapian::NumberRangeProcessor price_proc(0, &quot;$&quot;);
Xapian::NumberRangeProcessor weight_proc(1, &quot;kg&quot;, Xapian::RP_SUFFIX);
qp.add_rangeprocessor(&amp;price_proc);
qp.add_rangeprocessor(&amp;weight_proc);
</pre>
<p>Then the user can enter queries like:</p>
<pre class="literal-block">
laptop $300..800 ..1.5kg
</pre>
<p>A common way to use this feature is with a prefix string which is a &quot;field
name&quot; followed by a colon, for example:</p>
<pre class="literal-block">
created:1/1/1999..1/1/2003
</pre>
<p>Each <tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt> is passed the start and end of the
range.  If it doesn't understand the range, it should
<tt class="docutils literal"><span class="pre">Xapian::Query(Xapian::Query::OP_INVALID)</span></tt>.  If it does understand the range,
it should return a query object matching the range (which will often use query
operator <tt class="docutils literal"><span class="pre">Xapian::Query::OP_VALUE_RANGE</span></tt> but can be any query).</p>
<p>In Xapian 1.2.1 and later, <tt class="docutils literal"><span class="pre">Xapian::QueryParser</span></tt> supports open-ended
ranges - if the start of the range is empty, that means any value less than
the end, and similarly if the end is empty, that means any value greater
than the start.  The start and end can't both be empty.</p>
</div>
<div class="section" id="rangeprocessor">
<h1><a class="toc-backref" href="#id2">RangeProcessor</a></h1>
<p>This understands any range passed which has the specified prefix or suffix.
If no prefix or suffix is specified it will match any range (so it's not
useful to specify further <tt class="docutils literal">RangeProcessor</tt> objects after such an object
as they can't match).</p>
<p>For example, suppose you have stored author names in value number 4, and want
the user to be able to filter queries by specifying ranges of values such as:</p>
<pre class="literal-block">
mars asimov..bradbury
</pre>
<p>To do this, you can use a <tt class="docutils literal">RangeProcessor</tt> like so:</p>
<pre class="literal-block">
Xapian::QueryParser qp;
Xapian::RangeProcessor author_proc(4);
qp.add_rangeprocessor(&amp;author_proc);
</pre>
<p>The parsed query will use <tt class="docutils literal">OP_VALUE_RANGE</tt>, so <tt class="docutils literal">query.get_description()</tt>
would report:</p>
<pre class="literal-block">
Xapian::Query(mars:(pos=1) FILTER (VALUE_RANGE 4 asimov bradbury)
</pre>
<p>The <tt class="docutils literal">VALUE_RANGE</tt> subquery will only match documents where value 4 is
&gt;= asimov and &lt;= bradbury (using a string comparison).</p>
</div>
<div class="section" id="daterangeprocessor">
<h1><a class="toc-backref" href="#id3">DateRangeProcessor</a></h1>
<p>This class allows you to implement date range searches.  As well as the value
number to search, you can tell it whether to prefer US-style month/day/year
or European-style day/month/year (by using the <tt class="docutils literal"><span class="pre">Xapian::RP_DATE_PREFER_MDY</span></tt>
flag), and specify the epoch year to use for interpreting 2 digit years (the
default is day/month/year with an epoch of 1970).  The best choice of settings
depends on the expectations of your users.  As these settings are only applied
at search time, you can also easily offer different versions of your search
front-end with different settings if that is useful.</p>
<p>For example, if your users are American and the dates present in your database
can extend a decade or so into the future, you might use something like this
which specifies to prefer US-style dates and that the epoch year is 1930 (so
02/01/29 is February 1st 2029 while 02/01/30 is February 1st 1930):</p>
<pre class="literal-block">
Xapian::QueryParser qp;
Xapian::DateRangeProcessor date_proc(0, Xapian::RP_DATE_PREFER_MDY, 1930);
qp.add_rangeprocessor(&amp;date_proc);
</pre>
<p>The dates are converted to the format YYYYMMDD, so the values you index also
need to also be in this format - for example, if <tt class="docutils literal">doc_time</tt> is a <tt class="docutils literal">time_t</tt>:</p>
<pre class="literal-block">
char buf[9];
if (strftime(buf, sizeof(buf), &quot;%Y%m%d&quot;, gmtime(&amp;doc_time))) {
    doc.add_value(0, buf);
}
</pre>
</div>
<div class="section" id="numberrangeprocessor">
<h1><a class="toc-backref" href="#id4">NumberRangeProcessor</a></h1>
<p>This class allows you to implement numeric range searches.  The numbers used
may be any number which is representable as a double, but requires that the
stored values which the range is being applied have been converted to strings
at index time using the <tt class="docutils literal"><span class="pre">Xapian::sortable_serialise()</span></tt> method:</p>
<pre class="literal-block">
Xapian::Document doc;
doc.add_value(0, Xapian::sortable_serialise(price));
</pre>
<p>This method produces strings which will sort in numeric order, so you can use
it if you want to be able to sort based on the value in numeric order, too.</p>
</div>
<div class="section" id="custom-subclasses">
<h1><a class="toc-backref" href="#id5">Custom subclasses</a></h1>
<p>You can easily create your own subclasses of <tt class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></tt>.
Your subclass needs to implement a method
<tt class="docutils literal"><span class="pre">Xapian::Query</span> <span class="pre">operator()(const</span> <span class="pre">std::string</span> &amp;begin, const <span class="pre">std::string</span> &amp;end)</tt>
so for example you could implement a better version of the author range
described above which only matches ranges with a prefix (e.g.
<tt class="docutils literal"><span class="pre">author:asimov..bradbury</span></tt>) and lower-cases the names:</p>
<pre class="literal-block">
struct AuthorRangeProcessor : public Xapian::RangeProcessor {
    AuthorRangeProcessor() : RangeProcessor(4, &quot;author:&quot;) { }

    Xapian::valueno operator()(const std::string&amp; b, const std::string&amp; e) {
        // Let the base class do the prefix check.
        return RangeProcessor::operator()(Xapian::Unicode::tolower(b),
                                          Xapian::Unicode::tolower(e));
    }
};
</pre>
<p>If you want to support open-ended ranges, you need to handle begin or end
being empty suitably.  <tt class="docutils literal"><span class="pre">Xapian::QueryParser</span></tt> won't call your subclass
with <em>both</em> begin and end being empty.</p>
</div>
<div class="section" id="using-several-rangeprocessors">
<h1><a class="toc-backref" href="#id6">Using Several RangeProcessors</a></h1>
<p>If you want to allow the user to specify different types of ranges, you can
specify multiple <tt class="docutils literal">RangeProcessor</tt> objects to use.  Just add them in
the order you want them to be checked:</p>
<pre class="literal-block">
Xapian::QueryParser qp;
AuthorRangeProcessor author_proc();
qp.add_rangeprocessor(&amp;author_proc);
Xapian::DateRangeProcessor date_proc(0, 0, 1930);
qp.add_rangeprocessor(&amp;date_proc);
</pre>
<p>And then you can parse queries such as
<tt class="docutils literal">mars <span class="pre">author:Asimov..Bradbury</span> <span class="pre">01/01/1960..31/12/1969</span></tt> successfully.</p>
</div>
</div>
</body>
</html>
